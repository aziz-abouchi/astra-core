-- examples/05-type-driven-development/safe_protocols.heaven
-- Type-Driven Development avec types dépendants
-- Protocoles sûrs, vecteurs dimensionnés, et états au niveau des types

module TypeDriven

import Data.Vect
import Data.Fin
import Decidable.Equality

-- =============================================================================
-- PARTIE 1: Vecteurs avec taille au niveau des types
-- =============================================================================

-- Vecteur de taille n connue statiquement
data Vect : Nat -> Type -> Type where
  Nil : Vect Z a
  (::) : a -> Vect n a -> Vect (S n) a

-- head qui ne peut PAS échouer (garanti par le type)
head : Vect (S n) a -> a
head (x :: xs) = x
-- Impossible d'appeler head sur Nil (rejeté à la compilation)

-- tail aussi sûr
tail : Vect (S n) a -> Vect n a
tail (x :: xs) = xs

-- append préserve les tailles
append : Vect n a -> Vect m a -> Vect (n + m) a
append [] ys = ys
append (x :: xs) ys = x :: append xs ys

-- zip qui nécessite des vecteurs de même taille
zip : Vect n a -> Vect n b -> Vect n (a, b)
zip [] [] = []
zip (x :: xs) (y :: ys) = (x, y) :: zip xs ys
-- zip [1,2] [3] est REJETÉ à la compilation !

-- replicate crée un vecteur de taille exacte
replicate : (n : Nat) -> a -> Vect n a
replicate Z x = []
replicate (S k) x = x :: replicate k x

-- index sûr avec Fin (nombre fini)
data Fin : Nat -> Type where
  FZ : Fin (S n)           -- 0 dans un ensemble de taille S n
  FS : Fin n -> Fin (S n)  -- Successeur

-- index ne peut PAS sortir des bornes
index : Fin n -> Vect n a -> a
index FZ (x :: xs) = x
index (FS i) (x :: xs) = index i xs

-- Exemple: matrice type-safe
Matrix : Nat -> Nat -> Type -> Type
Matrix rows cols a = Vect rows (Vect cols a)

-- Multiplication matricielle avec vérification des dimensions
matMul : Num a => Matrix r c1 a -> Matrix c1 c2 a -> Matrix r c2 a
matMul [] _ = []
matMul (row :: rows) mat2 = 
  let row' = map (dotProduct row) (transpose mat2)
  in row' :: matMul rows mat2
  where
    dotProduct : Vect n a -> Vect n a -> a
    dotProduct xs ys = sum (zipWith (*) xs ys)

-- =============================================================================
-- PARTIE 2: États au niveau des types (Protocoles type-safe)
-- =============================================================================

-- État d'une connexion réseau
data ConnectionState = Closed | Open | Authenticated

-- Socket avec état au niveau du type
data Socket : ConnectionState -> Type where
  MkSocket : FileDescriptor -> Socket st

-- Opérations dépendantes de l'état
connect : Socket Closed -> IO (Socket Open)
connect sock = do
  fd <- performConnect (getFd sock)
  pure $ MkSocket fd

-- On ne peut pas authentifier une socket fermée (rejeté à la compilation)
authenticate : Socket Open -> Credentials -> IO (Socket Authenticated)
authenticate sock creds = do
  success <- performAuth (getFd sock) creds
  if success
    then pure $ MkSocket (getFd sock)
    else error "Authentication failed"

-- send nécessite une socket authentifiée
send : Socket Authenticated -> Data -> IO ()
send sock data = performSend (getFd sock) data

-- close fonctionne sur n'importe quel état
close : Socket st -> IO (Socket Closed)
close sock = do
  performClose (getFd sock)
  pure $ MkSocket (getFd sock)

-- Protocole complet type-safe
secureProtocol : IO ()
secureProtocol = do
  sock <- createSocket        -- Socket Closed
  sock' <- connect sock        -- Socket Open
  sock'' <- authenticate sock' credentials  -- Socket Authenticated
  send sock'' myData           -- OK
  -- send sock' myData         -- ERREUR DE COMPILATION !
  close sock''

-- =============================================================================
-- PARTIE 3: Machine à états finie (FSM) au niveau des types
-- =============================================================================

-- États d'un distributeur automatique
data VendingState = Ready | HasCoin | Dispensing

-- Machine avec état courant au niveau du type
data VendingMachine : VendingState -> Type where
  MkVM : Balance -> Stock -> VendingMachine st

-- Transitions légales uniquement
insertCoin : VendingMachine Ready -> VendingMachine HasCoin
insertCoin (MkVM bal stock) = MkVM (bal + 1) stock

-- On ne peut PAS insérer de pièce si on en a déjà une
-- insertCoin : VendingMachine HasCoin -> ...  -- N'existe pas !

selectItem : VendingMachine HasCoin -> ItemCode -> 
             Either (VendingMachine HasCoin) (VendingMachine Dispensing)
selectItem vm@(MkVM bal stock) code =
  if hasItem stock code
    then Right $ MkVM bal (decrementStock stock code)
    else Left vm

dispense : VendingMachine Dispensing -> IO (VendingMachine Ready)
dispense (MkVM bal stock) = do
  performDispense
  pure $ MkVM bal stock

-- Workflow complet vérifié par les types
buySnack : IO ()
buySnack = do
  let machine = initialMachine  -- VendingMachine Ready
  let withCoin = insertCoin machine  -- VendingMachine HasCoin
  
  case selectItem withCoin A1 of
    Right dispensing => do
      ready <- dispense dispensing
      pure ()
    Left withCoin' => 
      putStrLn "Item not available"

-- =============================================================================
-- PARTIE 4: Preuves au niveau des types (Égalités)
-- =============================================================================

-- Preuve d'égalité
data (=) : a -> a -> Type where
  Refl : x = x

-- Symétrie de l'égalité
sym : x = y -> y = x
sym Refl = Refl

-- Transitivité
trans : x = y -> y = z -> x = z
trans Refl Refl = Refl

-- Congruence (si x = y alors f x = f y)
cong : (f : a -> b) -> x = y -> f x = f y
cong f Refl = Refl

-- Preuves arithmétiques
plusZeroRightNeutral : (n : Nat) -> n + Z = n
plusZeroRightNeutral Z = Refl
plusZeroRightNeutral (S k) = cong S (plusZeroRightNeutral k)

plusSuccRightSucc : (left : Nat) -> (right : Nat) -> 
                    S (left + right) = left + S right
plusSuccRightSucc Z right = Refl
plusSuccRightSucc (S k) right = cong S (plusSuccRightSucc k right)

plusCommutative : (left : Nat) -> (right : Nat) -> 
                  left + right = right + left
plusCommutative Z right = sym (plusZeroRightNeutral right)
plusCommutative (S k) right = 
  rewrite plusSuccRightSucc right k in
  cong S (plusCommutative k right)

-- =============================================================================
-- PARTIE 5: Types dépendants pour validation
-- =============================================================================

-- String non vide au niveau du type
data NonEmpty : String -> Type where
  MkNonEmpty : (s : String) -> {auto ok : NonNull s} -> NonEmpty s

-- Email valide
data ValidEmail : String -> Type where
  MkEmail : (s : String) -> {auto ok : IsValidEmail s} -> ValidEmail s

-- Nombre dans une plage
data InRange : Nat -> Nat -> Nat -> Type where
  MkInRange : (n : Nat) -> {auto ok : min <= n && n <= max} -> 
              InRange min max n

-- User avec validation au niveau du type
record SafeUser where
  constructor MkSafeUser
  name : NonEmpty String
  email : ValidEmail String
  age : InRange 0 150 Nat

-- Impossible de créer un SafeUser invalide
createUser : (name : String) -> (email : String) -> (age : Nat) -> 
             Either ValidationError SafeUser
createUser name email age = do
  validName <- validateNonEmpty name
  validEmail <- validateEmail email
  validAge <- validateRange 0 150 age
  pure $ MkSafeUser validName validEmail validAge

-- =============================================================================
-- PARTIE 6: Ressources linéaires (use-once types)
-- =============================================================================

-- Type linéaire (doit être utilisé exactement une fois)
data Linear : Type -> Type where
  MkLinear : a -> Linear a

-- File handle linéaire (doit être fermé)
data FileHandle : Type where
  MkHandle : LinearResource -> FileHandle

-- openFile retourne un handle linéaire
openFile : FilePath -> IO (Linear FileHandle)
openFile path = do
  handle <- performOpen path
  pure $ MkLinear (MkHandle handle)

-- readFile consomme et retourne le handle
readFile : Linear FileHandle -> IO (String, Linear FileHandle)
readFile (MkLinear handle) = do
  content <- performRead handle
  pure (content, MkLinear handle)

-- closeFile consomme le handle définitivement
closeFile : Linear FileHandle -> IO ()
closeFile (MkLinear handle) = performClose handle

-- Usage correct vérifié par le système de types
safeFileOperations : IO ()
safeFileOperations = do
  handle <- openFile "data.txt"
  (content, handle') <- readFile handle
  -- On ne peut plus utiliser 'handle' ici, seulement 'handle''
  closeFile handle'
  -- handle' n'existe plus, impossible de l'utiliser
  pure ()

-- =============================================================================
-- PARTIE 7: Indexed Monads (État au niveau du type)
-- =============================================================================

-- Monade indexée par état initial et final
data IxMonad : (Type -> Type -> Type -> Type) -> Type where
  IxReturn : a -> m i i a
  IxBind : m i j a -> (a -> m j k b) -> m i k b

-- Example: File operations avec états
data FileOp : FileState -> FileState -> Type -> Type where
  Open : FilePath -> FileOp Closed Open ()
  Read : FileOp Open Open String
  Write : String -> FileOp Open Open ()
  Close : FileOp Open Closed ()

-- Programme type-safe
fileProgram : FileOp Closed Closed String
fileProgram = do
  Open "data.txt"     -- Closed -> Open
  content <- Read     -- Open -> Open
  Write "modified"    -- Open -> Open
  Close               -- Open -> Closed
  pure content        -- Final: Closed

-- =============================================================================
-- PARTIE 8: Dependent Pairs (Sigma types)
-- =============================================================================

-- Paire dépendante: le type du second élément dépend du premier
data DPair : (a : Type) -> (P : a -> Type) -> Type where
  MkDPair : (x : a) -> P x -> DPair a P

-- Syntaxe plus lisible
syntax "exists" {x} ":" [a] "." [p] = DPair a (\x => p)

-- Vecteur de taille existentielle
SomeVect : Type -> Type
SomeVect a = exists n : Nat . Vect n a

-- Créer un vecteur sans connaître la taille à l'avance
fromList : List a -> SomeVect a
fromList [] = MkDPair Z []
fromList (x :: xs) = 
  let MkDPair n vect = fromList xs
  in MkDPair (S n) (x :: vect)

-- Filter préserve l'invariant mais change la taille
filter : (a -> Bool) -> Vect n a -> SomeVect a
filter p [] = MkDPair Z []
filter p (x :: xs) =
  let MkDPair n xs' = filter p xs
  in if p x
     then MkDPair (S n) (x :: xs')
     else MkDPair n xs'

-- =============================================================================
-- PARTIE 9: Refinement Types
-- =============================================================================

-- Type raffiné: valeur avec prédicat
data Refined : (a : Type) -> (a -> Bool) -> Type where
  MkRefined : (x : a) -> {auto prf : p x = True} -> Refined a p

-- Exemples
Positive : Type
Positive = Refined Nat (> 0)

Even : Type  
Even = Refined Nat (\n => n `mod` 2 == 0)

SortedList : Type -> Type
SortedList a = Refined (List a) isSorted

-- Division sûre (diviseur garanti non-zéro)
safeDiv : Nat -> Positive -> Nat
safeDiv n (MkRefined d) = n `div` d

-- head sur liste non-vide garantie
safeHead : Refined (List a) nonEmpty -> a
safeHead (MkRefined (x :: xs)) = x

-- =============================================================================
-- Exemple complet: Parseur type-safe avec états
-- =============================================================================

data ParseState = Start | InToken | InString | Done

data Parser : ParseState -> ParseState -> Type -> Type where
  Pure : a -> Parser s s a
  
  Bind : Parser s1 s2 a -> (a -> Parser s2 s3 b) -> Parser s1 s3 b
  
  Char : Parser s s Char
  
  StartToken : Parser Start InToken ()
  
  EndToken : Parser InToken Start String
  
  StartString : Parser Start InString ()
  
  EndString : Parser InString Start String

-- Programme de parsing vérifié par les types
parseExpr : Parser Start Start Expr
parseExpr = do
  StartToken
  name <- EndToken
  StartString
  value <- EndString
  pure $ MkExpr name value

-- Point d'entrée avec exemples
main : IO ()
main = do
  putStrLn "=== Type-Driven Development ==="
  
  -- Vecteurs sûrs
  let v1 : Vect 3 Int = [1, 2, 3]
  let v2 : Vect 3 Int = [4, 5, 6]
  putStrLn "head v1: \{show (head v1)}"
  
  -- Protocole réseau type-safe
  secureProtocol
  
  -- Machine à états
  buySnack
  
  -- Preuve
  putStrLn "2 + 3 = 3 + 2 prouvé au niveau des types ✓"
  
  -- Fichiers linéaires
  safeFileOperations
