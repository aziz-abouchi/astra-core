-- examples/03-microservices/user_service_with_otp.astra
-- Microservice avec GenServer, Supervisor et Pony capabilities
-- Architecture OTP complète pour production

module UserService

import OTP.GenServer
import OTP.Supervisor
import OTP.Application
import Web.HTTP
import Data.Cache
import Database.PostgreSQL

-- Types de base
data UserId = MkUserId String

record User where
  constructor MkUser
  id : UserId
  email : String
  name : String
  createdAt : Time
  profile : UserProfile

record UserProfile where
  constructor MkProfile
  avatarUrl : Maybe String
  bio : Maybe String

-- Messages GenServer pour UserService
data UserCall
  = GetUser UserId
  | GetUserStats UserId
  | ValidateEmail String

data UserCast
  = CacheUser User
  | InvalidateCache UserId
  | UpdateMetrics UserMetrics

data UserInfo
  = CleanupCache
  | RefreshConnections

-- État du GenServer
record UserServiceState where
  constructor MkUserState
  cache : Cache UserId User
  dbPool : ConnectionPool
  config : ServiceConfig
  metrics : ServiceMetrics

record ServiceConfig where
  constructor MkConfig
  port : Nat
  dbUrl : String
  cacheUrl : String
  cacheTTL : Duration
  poolSize : Nat

-- GenServer behavior pour UserService (avec Pony capabilities)
behavior UserService : GenServer UserCall UserCast UserInfo UserServiceState
  with cacheCapability : ref    -- Mutable partagé pour le cache
     , dbCapability : val       -- Immutable pour connexions DB
  where
  init : ServiceConfig -> Effect (InitResult UserServiceState)
  init config = do
    logInfo "Initialisation UserService sur port \{show config.port}"
    
    -- Initialisation ressources
    cache <- connectCache config.cacheUrl
    dbPool <- createPool config.dbUrl config.poolSize
    
    -- Schedule cleanup périodique
    schedule CleanupCache (minutes 5)
    schedule RefreshConnections (minutes 30)
    
    let initialMetrics = MkServiceMetrics Z Z Z 0.0
    pure $ InitOk (MkUserState cache dbPool config initialMetrics) infinity
  
  -- Calls synchrones (avec timeout)
  handleCall : UserCall -> From -> UserServiceState -> Effect (CallResult UserServiceState)
  handleCall (GetUser userId) from state = do
    -- Tentative cache d'abord
    cached <- cacheGet state.cache userId
    
    case cached of
      Just user => do
        incrementMetric CacheHit
        pure $ Reply (Right user) state
      
      Nothing => do
        -- Fallback DB avec retry
        result <- retryWithBackoff 3 (millis 100) $
                    queryUser userId state.dbPool
        
        case result of
          Right user => do
            -- Mise en cache async
            spawn $ cacheSet state.cache userId user state.config.cacheTTL
            incrementMetric CacheMiss
            pure $ Reply (Right user) state
          
          Left err => do
            incrementMetric QueryError
            pure $ Reply (Left err) state
  
  handleCall (GetUserStats userId) from state = do
    stats <- computeUserStats userId state.dbPool
    pure $ Reply stats state
  
  handleCall (ValidateEmail email) from state = do
    exists <- emailExists email state.dbPool
    pure $ Reply exists state
  
  -- Casts asynchrones (fire and forget)
  handleCast : UserCast -> UserServiceState -> Effect (CastResult UserServiceState)
  handleCast (CacheUser user) state = do
    cacheSet state.cache user.id user state.config.cacheTTL
    pure $ NoReply state
  
  handleCast (InvalidateCache userId) state = do
    cacheDelete state.cache userId
    logInfo "Cache invalidé pour \{show userId}"
    pure $ NoReply state
  
  handleCast (UpdateMetrics metrics) state =
    pure $ NoReply (record { metrics = metrics } state)
  
  -- Info messages (timers, etc.)
  handleInfo : UserInfo -> UserServiceState -> Effect (InfoResult UserServiceState)
  handleInfo CleanupCache state = do
    cleaned <- cacheCleanup state.cache
    logInfo "Cache cleanup: \{show cleaned} entrées supprimées"
    schedule CleanupCache (minutes 5)
    pure $ NoReply state
  
  handleInfo RefreshConnections state = do
    dbPool' <- refreshPool state.dbPool
    schedule RefreshConnections (minutes 30)
    pure $ NoReply (record { dbPool = dbPool' } state)
  
  -- Cleanup à la terminaison
  terminate : Reason -> UserServiceState -> Effect ()
  terminate reason state = do
    logInfo "UserService terminé: \{show reason}"
    closeCache state.cache
    closePool state.dbPool

-- GenServer pour les permissions (séparé)
data PermissionCall
  = GetPermissions UserId
  | CheckPermission UserId Action

data PermissionCast
  = AddPermission UserId Action
  | RevokePermission UserId Action
  | SyncPermissions (List Permission)

record PermissionState where
  constructor MkPermState
  permCache : Map UserId (List Action)
  dbPool : ConnectionPool
  lastSync : Time

behavior PermissionService : GenServer PermissionCall PermissionCast () PermissionState
  with permCapability : iso  -- Capability isolée pour permissions
  where
  init : ConnectionPool -> Effect (InitResult PermissionState)
  init pool = do
    logInfo "Démarrage PermissionService"
    now <- currentTime
    pure $ InitOk (MkPermState empty pool now)
  
  handleCall : PermissionCall -> From -> PermissionState -> Effect (CallResult PermissionState)
  handleCall (GetPermissions userId) from state = do
    -- Vérifier cache local d'abord
    case lookup userId state.permCache of
      Just actions => pure $ Reply actions state
      Nothing => do
        -- Query DB
        actions <- queryPermissions userId state.dbPool
        let newCache = insert userId actions state.permCache
        pure $ Reply actions (record { permCache = newCache } state)
  
  handleCall (CheckPermission userId action) from state = do
    actions <- getPermissionsInternal userId state
    pure $ Reply (action `elem` actions) state
  
  handleCast : PermissionCast -> PermissionState -> Effect (CastResult PermissionState)
  handleCast (AddPermission userId action) state = do
    insertPermission userId action state.dbPool
    let current = lookupOr [] userId state.permCache
    let updated = action :: current
    let newCache = insert userId updated state.permCache
    
    -- Notification
    broadcast "permission.added" (userId, action)
    
    pure $ NoReply (record { permCache = newCache } state)
  
  handleCast (RevokePermission userId action) state = do
    deletePermission userId action state.dbPool
    let current = lookupOr [] userId state.permCache
    let updated = filter (/= action) current
    let newCache = insert userId updated state.permCache
    pure $ NoReply (record { permCache = newCache } state)

-- GenServer pour circuit breaker avec état
data CircuitCall
  = AttemptCall String (IO a)
  | GetCircuitStatus String

data CircuitCast
  = RecordSuccess String
  | RecordFailure String
  | ResetCircuit String

record CircuitState = Closed | Open | HalfOpen

record CircuitBreakerState where
  constructor MkCircuitState
  circuits : Map String CircuitInfo
  config : CircuitConfig

record CircuitInfo where
  constructor MkCircuitInfo
  state : CircuitState
  failureCount : Nat
  lastFailure : Maybe Time
  successCount : Nat

behavior CircuitBreaker : GenServer CircuitCall CircuitCast () CircuitBreakerState
  with circuitCapability : ref  -- Mutable partagé
  where
  init : CircuitConfig -> Effect (InitResult CircuitBreakerState)
  init config = do
    logInfo "Circuit Breaker initialisé"
    pure $ InitOk (MkCircuitState empty config)
  
  handleCall : CircuitCall -> From -> CircuitBreakerState -> Effect (CallResult CircuitBreakerState)
  handleCall (AttemptCall name action) from state = do
    let circuit = lookupOr defaultCircuit name state.circuits
    
    case circuit.state of
      Open => do
        -- Vérifier si timeout expiré
        shouldReset <- checkTimeout circuit state.config.timeout
        if shouldReset
          then handleHalfOpen name action circuit state
          else pure $ Reply (Left CircuitOpenError) state
      
      Closed => handleClosed name action circuit state
      HalfOpen => handleHalfOpen name action circuit state
  
  handleCast : CircuitCast -> CircuitBreakerState -> Effect (CastResult CircuitBreakerState)
  handleCast (RecordSuccess name) state = do
    let circuit = lookupOr defaultCircuit name state.circuits
    let updated = record { successCount = S circuit.successCount
                         , failureCount = Z } circuit
    let newCircuits = insert name updated state.circuits
    pure $ NoReply (record { circuits = newCircuits } state)
  
  handleCast (RecordFailure name) state = do
    let circuit = lookupOr defaultCircuit name state.circuits
    now <- currentTime
    let newCount = S circuit.failureCount
    let updated = record { failureCount = newCount
                         , lastFailure = Just now } circuit
    
    -- Ouvrir le circuit si threshold dépassé
    let finalState = if newCount >= state.config.threshold
                     then record { state = Open } updated
                     else updated
    
    let newCircuits = insert name finalState state.circuits
    pure $ NoReply (record { circuits = newCircuits } state)

-- Supervisor principal pour le microservice
microserviceSupervisor : ServiceConfig -> SupervisorSpec
microserviceSupervisor config = MkSupervisor
  { strategy = OneForOne
  , intensity = 10
  , period = seconds 60
  , children =
      [ -- Core service
        worker "user_service"
          (startLink UserService config)
          Permanent
          (seconds 5)
      
      , -- Permission service
        worker "permission_service"
          (startLink PermissionService (createPool config.dbUrl 5))
          Permanent
          (seconds 5)
      
      , -- Circuit breaker
        worker "circuit_breaker"
          (startLink CircuitBreaker defaultCircuitConfig)
          Permanent
          (seconds 5)
      
      , -- HTTP handler (supervisor son propre pool)
        supervisor "http_pool"
          (httpPoolSupervisor config.port)
          Permanent
          infinity
      ]
  }

-- Supervisor pour le pool de handlers HTTP
httpPoolSupervisor : Nat -> SupervisorSpec
httpPoolSupervisor port = MkSupervisor
  { strategy = OneForOne
  , intensity = 20
  , period = seconds 60
  , children = map makeHandler [1..10]  -- Pool de 10 handlers
  }
  where
    makeHandler : Nat -> ChildSpec
    makeHandler n =
      worker "http_handler_\{show n}"
        (startLink HttpHandler port)
        Transient  -- Redémarré seulement si termine anormalement
        (seconds 5)

-- Application OTP principale
behavior UserManagementApp : Application where
  start : StartType -> List String -> Effect (Either Error Pid)
  start startType args = do
    logInfo "Démarrage User Management Application"
    
    -- Configuration depuis environnement
    config <- loadConfigFromEnv
    
    -- Démarrer le supervisor principal
    result <- Supervisor.startLink (microserviceSupervisor config)
    
    case result of
      Right supPid => do
        -- Enregistrement des services
        register "user_service" =<< whereis "user_service"
        register "permission_service" =<< whereis "permission_service"
        register "circuit_breaker" =<< whereis "circuit_breaker"
        
        -- Distribution sur cluster
        distributeServices
        
        -- Démarrer serveur HTTP
        startHttpServer config.port
        
        -- Métriques Prometheus
        spawn $ serveMetrics 9090
        
        logInfo "Application opérationnelle sur port \{show config.port}"
        pure $ Right supPid
      
      Left err => do
        logError "Échec démarrage: \{show err}"
        pure $ Left err
  
  stop : AppState -> Effect ()
  stop state = do
    logInfo "Arrêt graceful de l'application"
    stopHttpServer
    closeAllConnections

-- Distribution des services
distributeServices : Effect ()
distributeServices = do
  userPid <- whereis "user_service"
  permPid <- whereis "permission_service"
  
  -- Load balancing sur plusieurs nœuds
  distributeProcess userPid "web-1@api-cluster"
  distributeProcess permPid "api-1@api-cluster"

-- Handler HTTP qui utilise les GenServers
handleHttpRequest : HttpRequest -> Effect HttpResponse
handleHttpRequest req = do
  userService <- whereis "user_service"
  
  case parseRoute req of
    GetUserRoute userId => do
      -- Call synchrone avec timeout
      result <- GenServer.call userService (GetUser userId) (seconds 5)
      case result of
        Right user => pure $ okJson user
        Left err => pure $ notFoundJson err
    
    CreateUserRoute userData => do
      -- Validation
      valid <- GenServer.call userService (ValidateEmail userData.email) (seconds 2)
      if valid
        then pure $ conflictJson "Email exists"
        else do
          user <- createUserInDb userData
          -- Cache async
          GenServer.cast userService (CacheUser user)
          pure $ createdJson user
    
    _ => pure $ notFound "Route not found"

-- Point d'entrée
main : IO ()
main = do
  result <- Application.start UserManagementApp Normal []
  
  case result of
    Right supPid => do
      putStrLn "✓ User Management System démarré"
      putStrLn "  Supervisor: \{show supPid}"
      putStrLn "  API: http://localhost:8080"
      putStrLn "  Métriques: http://localhost:9090/metrics"
      putStrLn "  Cluster: web-1@api-cluster, api-1@api-cluster"
      
      receive
    
    Left err => do
      putStrLn "✗ Échec: \{show err}"
      exitWith 1
