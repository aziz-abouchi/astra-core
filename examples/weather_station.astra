-- examples/01-reactive-systems/weather_station.astra
-- Syst√®me de station m√©t√©o distribu√©e avec OTP behaviors et Pony capabilities
-- Architecture OTP compl√®te avec GenServer, Supervisor et Application

module WeatherStation

import OTP.GenServer
import OTP.Supervisor
import OTP.Application
import Data.Stream
import Effect.Time

-- Types alg√©briques avec inf√©rence Hindley-Milner
data AlertLevel = Info | Warning | Critical

record WeatherData where
  constructor MkWeatherData
  temperature : Double
  humidity : Double
  pressure : Double
  timestamp : Time

record Alert where
  constructor MkAlert
  level : AlertLevel
  message : String
  data : WeatherData

-- Messages pour le GenServer
data StationCall
  = GetStatistics
  | GetLastReading

data StationCast
  = UpdateThreshold Double
  | ClearHistory

data StationInfo
  = Measure
  | CheckSensors

-- √âtat du GenServer
record StationState where
  constructor MkStationState
  location : String
  readings : List WeatherData
  alertThreshold : Double
  sensorStatus : SensorStatus

-- Behavior GenServer pour la station m√©t√©o (style OTP)
behavior WeatherStationServer : GenServer StationCall StationCast StationInfo StationState where
  -- Initialisation (OTP init callback)
  init : String -> Effect (InitResult StationState)
  init location = do
    logInfo "Initialisation station m√©t√©o √† \{location}"
    schedule Measure (seconds 5)
    pure $ InitOk (MkStationState location [] 35.0 Operational) (seconds 60)
  
  -- Handle synchrone (call) - avec r√©ponse
  handleCall : StationCall -> From -> StationState -> Effect (CallResult StationState)
  handleCall GetStatistics from state = do
    let stats = calculateStats state.readings
    pure $ Reply stats state
  
  handleCall GetLastReading from state =
    case head state.readings of
      Just reading => pure $ Reply reading state
      Nothing => pure $ Reply NoData state
  
  -- Handle asynchrone (cast) - sans r√©ponse
  handleCast : StationCast -> StationState -> Effect (CastResult StationState)
  handleCast (UpdateThreshold newThreshold) state = do
    logInfo "Mise √† jour seuil: \{show newThreshold}"
    pure $ NoReply (record { alertThreshold = newThreshold } state)
  
  handleCast ClearHistory state = do
    logInfo "Historique effac√©"
    pure $ NoReply (record { readings = [] } state)
  
  -- Handle info (messages internes/timers)
  handleInfo : StationInfo -> StationState -> Effect (InfoResult StationState)
  handleInfo Measure state = do
    -- Lecture des capteurs avec IO
    temp <- readSensor TemperatureSensor
    humid <- readSensor HumiditySensor
    press <- readSensor PressureSensor
    now <- currentTime
    
    let reading = MkWeatherData temp humid press now
    let newReadings = take 1000 (reading :: state.readings)
    
    -- Notification async vers AlertService
    when (temp > state.alertThreshold) $
      GenServer.cast alertService (ProcessAlert $ createAlert reading)
    
    -- Broadcast vers abonn√©s (pub/sub)
    broadcast "weather.reading" reading
    
    -- Re-schedule
    schedule Measure (seconds 5)
    pure $ NoReply (record { readings = newReadings } state)
  
  handleInfo CheckSensors state = do
    status <- verifySensors
    pure $ NoReply (record { sensorStatus = status } state)
  
  -- Terminate (cleanup)
  terminate : Reason -> StationState -> Effect ()
  terminate reason state = do
    logInfo "Arr√™t station: \{show reason}"
    closeSensors

-- Behavior GenServer pour le service d'alertes
data AlertCall
  = GetAlertHistory
  | GetAlertCount

data AlertCast
  = ProcessAlert Alert
  | Subscribe Pid
  | Unsubscribe Pid

record AlertState where
  constructor MkAlertState
  subscribers : List Pid
  history : List Alert
  countByLevel : Map AlertLevel Nat

behavior AlertServer : GenServer AlertCall AlertCast () AlertState where
  init : () -> Effect (InitResult AlertState)
  init () = do
    logInfo "D√©marrage service d'alertes"
    pure $ InitOk (MkAlertState [] [] empty)
  
  handleCall : AlertCall -> From -> AlertState -> Effect (CallResult AlertState)
  handleCall GetAlertHistory from state =
    pure $ Reply state.history state
  
  handleCall GetAlertCount from state =
    let total = length state.history
    in pure $ Reply total state
  
  handleCast : AlertCast -> AlertState -> Effect (CastResult AlertState)
  handleCast (ProcessAlert alert) state = do
    let newHistory = take 10000 (alert :: state.history)
    let newCount = incrementCount alert.level state.countByLevel
    
    -- Broadcast vers abonn√©s avec Pony behavior
    traverse_ (\sub => GenServer.cast sub (NotifyAlert alert)) state.subscribers
    
    -- Action selon niveau avec pattern matching
    handleAlertLevel alert.level alert
    
    pure $ NoReply (record { history = newHistory
                           , countByLevel = newCount } state)
  
  handleCast (Subscribe pid) state = do
    logInfo "Nouvel abonn√©: \{show pid}"
    link pid  -- OTP link pour supervision
    pure $ NoReply (record { subscribers = pid :: state.subscribers } state)
  
  handleCast (Unsubscribe pid) state = do
    unlink pid
    let newSubs = filter (/= pid) state.subscribers
    pure $ NoReply (record { subscribers = newSubs } state)
  
  terminate : Reason -> AlertState -> Effect ()
  terminate _ state = do
    logInfo "Arr√™t service alertes, \{length state.history} alertes archiv√©es"

-- Pattern matching sur AlertLevel
handleAlertLevel : AlertLevel -> Alert -> Effect ()
handleAlertLevel Critical alert = do
  logCritical "üö® ALERTE CRITIQUE: \{alert.message}"
  GenServer.cast emergencyService (Emergency alert)

handleAlertLevel Warning alert =
  logWarning "‚ö†Ô∏è  ATTENTION: \{alert.message}"

handleAlertLevel Info alert =
  logInfo "‚ÑπÔ∏è  \{alert.message}"

-- Dashboard comme GenServer avec Pony behavior pour l'affichage
data DashboardCall = GetStatus

data DashboardCast
  = NotifyAlert Alert
  | UpdateReading WeatherData

record DashboardState where
  constructor MkDashboardState
  currentData : Maybe WeatherData
  alertCount : Nat
  lastUpdate : Time

-- Pony behavior pour capacit√©s (iso/val/ref/tag)
behavior Dashboard : GenServer DashboardCall DashboardCast () DashboardState 
  with displayCapability : iso  -- Capacit√© isol√©e pour l'affichage
  where
  init : () -> Effect (InitResult DashboardState)
  init () = do
    now <- currentTime
    pure $ InitOk (MkDashboardState Nothing Z now)
  
  handleCall : DashboardCall -> From -> DashboardState -> Effect (CallResult DashboardState)
  handleCall GetStatus from state =
    pure $ Reply (buildStatus state) state
  
  handleCast : DashboardCast -> DashboardState -> Effect (CastResult DashboardState)
  handleCast (NotifyAlert alert) state = do
    displayAlert alert  -- Utilise capability iso
    pure $ NoReply (record { alertCount = S state.alertCount } state)
  
  handleCast (UpdateReading data) state = do
    updateDisplay data  -- Utilise capability iso
    now <- currentTime
    pure $ NoReply (record { currentData = Just data
                           , lastUpdate = now } state)

-- Supervisor avec strat√©gie OTP (one_for_one, one_for_all, rest_for_one)
weatherSupervisor : SupervisorSpec
weatherSupervisor = MkSupervisor
  { strategy = OneForOne
  , intensity = 10        -- Max 10 restarts
  , period = seconds 60   -- Dans une p√©riode de 60s
  , children =
      [ -- Station m√©t√©o (permanent worker)
        worker "weather_station"
          (startLink WeatherStationServer "Paris-Centre")
          Permanent  -- Toujours red√©marr√©
          (seconds 5)
      
      , -- Service d'alertes (transient worker)
        worker "alert_service"
          (startLink AlertServer ())
          Transient  -- Red√©marr√© seulement si termine anormalement
          (seconds 5)
      
      , -- Dashboard (temporary worker)
        worker "dashboard"
          (startLink Dashboard ())
          Temporary  -- Jamais red√©marr√©
          (seconds 5)
      ]
  }

-- Application behavior (OTP Application)
behavior WeatherApp : Application where
  -- Start application (OTP callback)
  start : StartType -> List String -> Effect (Either Error Pid)
  start startType args = do
    logInfo "D√©marrage Weather Application"
    
    -- D√©marrer le supervisor
    result <- Supervisor.startLink weatherSupervisor
    
    case result of
      Right supPid => do
        -- Enregistrer les services globalement
        register "weather_station" =<< whereis "weather_station"
        register "alert_service" =<< whereis "alert_service"
        register "dashboard" =<< whereis "dashboard"
        
        -- Configuration distribution
        distributeServices
        
        pure $ Right supPid
      
      Left err => do
        logError "√âchec d√©marrage: \{show err}"
        pure $ Left err
  
  -- Stop application (OTP callback)
  stop : AppState -> Effect ()
  stop state = do
    logInfo "Arr√™t graceful de l'application"
    -- Le supervisor s'occupe d'arr√™ter les enfants

-- Configuration de la distribution (Erlang distributed)
distributeServices : Effect ()
distributeServices = do
  -- Station sur n≈ìud capteurs
  stationPid <- whereis "weather_station"
  distributeProcess stationPid "sensor-node@weather-cluster"
  
  -- Alertes sur n≈ìud processing
  alertPid <- whereis "alert_service"
  distributeProcess alertPid "processing-node@weather-cluster"
  
  -- Dashboard sur n≈ìud display
  dashPid <- whereis "dashboard"
  distributeProcess dashPid "display-node@weather-cluster"

-- Helper functions pures
createAlert : WeatherData -> Alert
createAlert data@(MkWeatherData temp _ _ _) =
  MkAlert (determineLevel temp) (formatMessage data) data
  where
    determineLevel : Double -> AlertLevel
    determineLevel t
      | t > 40.0 = Critical
      | t > 35.0 = Warning
      | otherwise = Info

formatMessage : WeatherData -> String
formatMessage (MkWeatherData temp humid press _) = 
  "Temp: \{show temp}¬∞C, Humid: \{show humid}%, Press: \{show press}hPa"

calculateStats : List WeatherData -> Statistics
calculateStats [] = emptyStats
calculateStats logs = 
  let temps = map (.temperature) logs
      avgTemp = sum temps / cast (length temps)
      maxTemp = maximum temps
      minTemp = minimum temps
  in MkStatistics avgTemp maxTemp minTemp (length logs)

incrementCount : AlertLevel -> Map AlertLevel Nat -> Map AlertLevel Nat
incrementCount level counts =
  insert level (lookupOr Z level counts + 1) counts

-- Point d'entr√©e avec Application behavior
main : IO ()
main = do
  -- D√©marrage de l'application OTP
  result <- Application.start WeatherApp Normal []
  
  case result of
    Right supPid => do
      putStrLn "‚úì Weather Monitoring System d√©marr√©"
      putStrLn "  Supervisor PID: \{show supPid}"
      putStrLn "  Station: sensor-node@weather-cluster"
      putStrLn "  Alertes: processing-node@weather-cluster"
      putStrLn "  Dashboard: display-node@weather-cluster"
      
      -- Abonner le dashboard aux alertes
      alertPid <- whereis "alert_service"
      dashPid <- whereis "dashboard"
      GenServer.cast alertPid (Subscribe dashPid)
      
      -- Attendre ind√©finiment (l'application OTP g√®re le lifecycle)
      receive
    
    Left err => do
      putStrLn "‚úó √âchec d√©marrage: \{show err}"
      exitWith 1
